---
title: 'lidR'
format:
  html:
    toc: true
    toc-location: left
    theme: simpelex

echo: true
---

```{r}
# install.packages('lidR')
library(lidR) 

file_name <- 'laz/bishops_peak.laz'
bp <- readLAS(file_name)
bp

```

Invalid data is not uncommon when it comes to aerial lidar.  It is a good idea to check the file integrity before starting.

```{r}
las_check(bp)
```

Notice that there are points marked as withheld.  Withheld points are typically points that are suspicious or have something wrong with them.  There ae not many in the point cloud, so we can safely drop them.  We will do this by adding the `filter="-drop_withheld"` parameter to `readLAS()`.

## Point Records
In a lidar file, the following attribute will always be included for points.


| Item                             | Format             | Size     | Required |
|----------------------------------|--------------------|----------|----------|
| X                                | long               | 4 bytes  | yes      |
| Y                                | long               | 4 bytes  | yes      |
| Z                                | long               | 4 bytes  | yes      |
| Intensity                        | unsigned short     | 2 bytes  | no       |
| ReturnNumber                    | 3 bits (bits 0–2)  | 3 bits   | yes      |
| Number of Returns (Given Pulse) | 3 bits (bits 3–5)  | 3 bits   | yes      |
| ScanDirectionFlag              | 1 bit (bit 6)      | 1 bit    | yes      |
| EdgeofFlightLine              | 1 bit (bit 7)      | 1 bit    | yes      |
| Classification                   | unsigned char      | 1 byte   | yes      |
| ScanAngleRank (-90 to +90)    | signed char        | 1 byte   | yes      |
| UserData                        | unsigned char      | 1 byte   | no       |
| PointSourceID                  | unsigned short     | 2 bytes  | yes      |


Sometimes there are other records associated with points, e.g. `HeightAboveGround`.


## Comparing workflows on two different types of forest
We will look at the Bishops Peak tile (coastal liv oak woodland), and a tile in Trinity County (Douglas-fir, ponderosa pine, canyon live oak, and knobcone pine woodland) in parallel.  

Here we do not need all of the attributes for the points. For many applications things like ScanAngleRank, are not useful.

Below we load only the x, y, z, intensity, number of returns, return number and classification.

We will also filter duplicates, as they can cause problems.

Finally we will run las_check on the trinity county tile.

```{r}
# bishops peak tile
bp <- readLAS(
  file_name, select="xyzinrc",filter="-drop_withheld"
)
bp <- filter_duplicates(bp)

# trinity county tile
tr <- readLAS(
  'laz/trinity_26910.laz', select="xyzinrc",filter="-drop_withheld"
)
tr <- filter_duplicates(tr)

las_check(tr)
```


The below will plot the point clouds in a 3D interactive window (if you are suing Rstudio, it would be possible in other IDEs as well, but things involving R usually require painstaking configuration).

```{r}
plot(bp)
plot(tr)
```

It is also fairly easy to plot transect profiles.

```{r}
library(ggplot2)

# bp points (found in QGIS)
p1 <- c(165002.6378679913, 3911266.6643020255)
p2 <- c(165067.0078679913, 3910900.6643020255)

# bp transect
bp_tr <- clip_transect(bp, p1, p2, width = 5, xz = TRUE)

# plot
ggplot(payload(bp_tr), aes(X,Z, color = Z)) + 
  geom_point(size = 0.5) + 
  coord_equal() + 
  theme_minimal() +
  scale_color_gradientn(colours = height.colors (50))
```

```{r}
# tr points (found in QGIS)
p3 <- c(517025.3000042647, 4553216.613794332)
p4 <- c(517069.9200042647, 4552737.033794332)

# bp transect
tr_tr <- clip_transect(tr, p3, p4, width = 5, xz = TRUE)

# plot
ggplot(payload(tr_tr), aes(X,Z, color = Z)) + 
  geom_point(size = 0.5) + 
  coord_equal() + 
  theme_minimal() +
  scale_color_gradientn(colours = height.colors (50))

```

Find Height Above Ground.  In lidR we assign it to Z, as the package does not handle extra dimensions.  In other applications we would probably add a `HeightAboveGround` dimension tot he point cloud.

```{r}
bp_normed <- normalize_height(bp, tin())
bp_normed <- filter_poi(bp_normed, Z >= 3 & Z <= 50)

# plot
bp_nrm_tr <- clip_transect(bp_normed, p1, p2, width = 5, xz = TRUE)

ggplot(payload(bp_nrm_tr), aes(X,Z, color = Z)) + 
  geom_point(size = 0.5) + 
  coord_equal() + 
  theme_minimal() +
  scale_color_gradientn(colours = height.colors (50))
```

```{r}
tr_normed <- normalize_height(tr, tin())
tr_normed <- filter_poi(tr_normed, Z >= 3 & Z <= 80)

# plot
tr_nrm_tr <- clip_transect(bp_normed, p3, p4, width = 5, xz = TRUE)

ggplot(payload(tr_nrm_tr), aes(X,Z, color = Z)) + 
  geom_point(size = 0.5) + 
  coord_equal() + 
  theme_minimal() +
  scale_color_gradientn(colours = height.colors (50))
```

Create CHMs

```{r}
bp_chm <- rasterize_canopy(
  bp_normed,
  res=0.5,
  pitfree(
    thresholds=c(0, 10, 20),
    max_edge=c(0, 1.5)
  )
)

plot(bp_chm)
```

````{r}
tr_chm <- rasterize_canopy(
  tr_normed,
  res=0.5,
  pitfree(
    thresholds=c(0, 10, 20),
    max_edge=c(0, 1.5)
  )
)

plot(tr_chm)
```

Smoothing the CHM tends to help the delineation and is standard practice.

```{r}
w <- matrix(1, 3, 3)

bp_smoothed <- terra::focal(bp_chm, w, fun=mean, na.rm=TRUE)

tr_smoothed <- terra::focal(tr_chm, w, fun=mean, na.rm=TRUE)
```

This height dependent window was designed for Klamath mountains, and will probably not work well on Bishops Peak.

```{r}
# find ttops with height dependent window size
wf <- function(x) {
  y <- abs(x/8)
  y[x <= 32] <- 4
  y[x > 80] <- 10
  return(y)
}
        
bp_ttops <- locate_trees(bp_smoothed, lmf(wf))
tr_ttops <- locate_trees(tr_smoothed, lmf(wf))
```

Lets see how this worked out.  Since the parameters used in the process were chosen for the Klamath Mountains, one would expect the Trinity County tile to have better results.

```{r}
# extent to clip raster for plotting
bp_sub <- sf::st_bbox(sf::st_buffer(sf::st_point(p2), 40))
plot(terra::crop(bp_chm, bp_sub), col=height.colors(50))
plot(sf::st_geometry(bp_ttops), add = TRUE, pch = 3)
```

```{r}
tr_sub <- sf::st_bbox(sf::st_buffer(sf::st_point(p4), 30))
plot(terra::crop(tr_chm, tr_sub), col=height.colors(50))
plot(sf::st_geometry(tr_ttops), add = TRUE, pch = 3)
```

Lets try a 3D plot

```{r}
x <- plot(tr_normed, bg = "white", size = 4)
add_treetops3d(x, tr_ttops)
```

Next segment trees and add [standard metrics(https://rdrr.io/cran/lidR/man/stdmetrics.html)].

```{r}
bp_segs = segment_trees(
  bp_normed,
  dalponte2016(bp_smoothed, bp_ttops)
)

tr_segs = segment_trees(
  tr_normed,
  dalponte2016(tr_smoothed, tr_ttops)
)

bp_crowns <- crown_metrics(
  bp_segs,
  func=.stdmetrics,
  geom='concave'
)

tr_crowns <- crown_metrics(
  tr_segs,
  func=.stdmetrics,
  geom='concave'
)

head(tr_crowns)
```