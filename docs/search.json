[
  {
    "objectID": "intro.html#section",
    "href": "intro.html#section",
    "title": "",
    "section": "",
    "text": "Today we will cover a few of the tools we will be using this quarter, which should hopefully be installed.\n+ git\n+ conda\n+ VScode\n+ Rstudio\n+ QGIS\n+ GDAL"
  },
  {
    "objectID": "python_geospatial_basics.html",
    "href": "python_geospatial_basics.html",
    "title": "Python Lectures",
    "section": "",
    "text": "It allows for more flexibility than a GUI based GIS program.\nOther GIS applications (e.g.¬†QGIS, ArcGIS, postGIS) often have a Python interface.\ngenerally a widely used language.\n\n\n\nBefore we get started we need to set up a Python environment in which to work. We will be using Anaconda for this.\n\nDownload the environment.yml\nIn the start menu search for Anaconda. Open an Anaconda Powershell.\n\ncd ~\nmkdir geog441\ncd geog441\ncp ~/Downloads/environment.yml .\nconda env create -f environment.yml\n\nFYI: What is this environment.yml thing?\nname: geo\nchannels:\n  - defaults\ndependencies: \n  - geopandas\n  - jupyterlab\n  - rioxarray\n  - tabulate\n  - tqdm\n\nUsing conda env create with the environment yaml creates a new conda environment named geo with the dependencies installed. Next we will activate the geo environment.\nconda activate geo\nNotice that the conda environment shown after the prompt has changed from (base) to (geo).\nIf later you find that you need another package you can add it to the environment (while in the environment) with conda install &lt;whatever_package&gt;.\nMore info on managing conda environments\n\n\n\njupyter lab\nThis will open a new jupyter lab in your browser. ## Using VScode\nRunning Jupyter in VScode offers some advantages (in my opinion). To do this you need to install the jupyter extension and the Python Extension. Then when you open a file with a .ipynb extension it will be treated as a Jupyter notebook.\n\n\n\n\n\n\n\n\n\n\nType\nExample(s)\n\n\n\n\nString\n'Dude!'\n\n\nFloat\n1.2\n\n\nInt\n3\n\n\nTuple\n('x', 'y')(1, 2)('x', 3.2)\n\n\nList\n['x', 'y'][1, 2]Possible but bad ‚Äì&gt; ['x', 3.2]\n\n\nDict\n{'dogs': 26, 'cats', 100}\n\n\netc‚Ä¶\nthere are others\n\n\n\n\n\n\nFloats and Ints don‚Äôt do anything all that surprising\n\na = 2 + 2\nb = 2.0 + 2.0\nc = a + b\n\n\nprint(f'a is an {type(a)}')\nprint(f'b is a {type(b)}')\nprint(f'c is a {type(c)}')\nprint(f'a / b is {a / b}')\nprint(f'5 / 4 is {5 / 4}')\nprint(f'but 5 // 4 is {5 // 4}')\nprint(f'and 5 % 4 is {5 % 4}')\n\na is an &lt;class 'int'&gt;\nb is a &lt;class 'float'&gt;\nc is a &lt;class 'float'&gt;\na / b is 1.0\n5 / 4 is 1.25\nbut 5 // 4 is 1\nand 5 % 4 is 1\n\n\n\n\n\nLists, tuples, and strings ae all sequences\n\n# a list\na_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# a tuple\na_tup = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n# a string\na_str = 'Wil je graag een neushorn?'\n\n# access by index\na = a_list[0]\nb = a_list[-1]\nc = a_list[4]\nprint(f'by index:\\n 0 --&gt; {a},\\n-1 --&gt; {b},\\n 4 --&gt; {c}')\n\n# works fro strings to\nprint('string item at 4 --&gt; ', a_str[4])\n\n# you can slice a list or tuple(remember 0 indexed)\nprint('\\nslices:')\nprint(a_list[2:5])\nprint(a_list[8:])\nprint(a_tup[2:5])\nprint(a_str[-9:])\n\nby index:\n 0 --&gt; 1,\n-1 --&gt; 9,\n 4 --&gt; 5\nstring item at 4 --&gt;  j\n\nslices:\n[3, 4, 5]\n[9]\n(3, 4, 5)\nneushorn?\n\n\nSlicing\nSequences tutorial\nSequence tutorial as video\nTHe key difference is that tuples are immutable.\n\na_list[1] = 256\n\na_tup[1] = 256\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 3\n      1 a_list[1] = 256\n----&gt; 3 a_tup[1] = 256\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\n\n\npets = {'honden': 26, 'katten': 100}\n\nfor key, val in pets.items():\n  print(f'{val} {key}')\n\nprint(f'{pets[\"honden\"] + pets[\"katten\"]} huisdieren')\n\n26 honden\n100 katten\n126 huisdieren\n\n\nMore on dictionaries\n\n\n\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# use a loop to append squared values to new lists\nb = []\nfor n in a:\n  b.append(n**2)\n\n# or, better, use a comprehension\nc = [n**2 for n in a]\n\nprint(b)\nprint('is the same as')\nprint(c)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\nis the same as\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\n\n\n\n\nDefined with def\nCan take arguments\ncan return something\nhave there own scope\n\n\nimport numpy as np\n\ndef root_mean_square(list_of_numbers):\n  rms = np.sqrt(\n    np.array([n**2 for n in list_of_numbers]).sum() /\n    len(list_of_numbers)\n    )\n\n  return rms\n\nl = [1.2, 3.3, 1.4, 1.4, 4.2]\nrms = root_mean_square(l)\n\nprint(rms)\n\n2.6034592372457075\n\n\nThey do nat have to have arguments or return stuff.\n\ndef complain():\n  print('This is boring!\\nwhen will we get to the GIS stuff.\\n\\U0001F620\\U0001F620\\U0001F620\\n\\nSoon! Bear with me.')\n\ncomplain()\n\nThis is boring!\nwhen will we get to the GIS stuff.\nüò†üò†üò†\n\nSoon! Bear with me.\n\n\n\n\n\nDataFrames hold tabular data\n\nfrom datetime import datetime, timedelta\nfrom random import uniform\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# some arbitrary time range \nstart_time = datetime(2025, 3, 1, 8, 0, 0)\nend_time = datetime(2025, 3, 3, 17, 0, 0)\ninterval = timedelta(minutes=30)\ntime_stamps = []\ncurrent_time = start_time\nwhile current_time &lt;= end_time:\n    time_stamps.append(current_time)\n    current_time += interval\n\n# some made up temperature data\ntemp_c = [\n  20 + uniform(-10, 10) + 10 *\n  np.sin(2 * np.pi * t.hour / 24)\n  for t\n  in time_stamps\n]\n\n# empty dataframe\ndf = pd.DataFrame()\n\n# add data\ndf['date_time'] = time_stamps\ndf['T (C)'] = temp_c\n\ndf.head()\n\n\n\n\n\n\n\n\ndate_time\nT (C)\n\n\n\n\n0\n2025-03-01 08:00:00\n32.275064\n\n\n1\n2025-03-01 08:30:00\n28.774465\n\n\n2\n2025-03-01 09:00:00\n21.673834\n\n\n3\n2025-03-01 09:30:00\n33.957310\n\n\n4\n2025-03-01 10:00:00\n26.920906\n\n\n\n\n\n\n\n\n\n\n\nfig, ax = plt.subplots()\n\n# create the scatter plot\nplt.scatter(df.date_time, df['T (C)'], marker='x', color = 'k')\n\n# set the x-axis tick labels and rotate them\nplt.xticks(rotation=80, ha='right')\n\n# label axes\nplt.xlabel('Day and Time')\nplt.ylabel('Temperature (C)')\nplt.title('Hourly Temperature (C) in West Crabhammer')\n\n# adjust layout to prevent labels from overlapping\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n# get the mean temperature over the timeseries\ndf['T (C)'].mean()\n\nnp.float64(19.81998889001604)\n\n\nWhen there are no spaces in a column name you can access the column as an attribute of the datafame.\n\n# get the number of time stamps in the date_time column\ndf.date_time.count()\n\nnp.int64(115)\n\n\nThere is a lot more to know about Pandas DataFrames. This is enough for us to move on to GeoPandas. I encourage you to learn more about Pandas as an exercise.\n\n\n\nIf you are choosing Python as you language in this course (and what we have covered today is not a peace of cake for you already), create a jupyter notebook and do the following:\n\n\nDownload the results from the class survey from here as a csv file.\nRead the csv into a Pandas DataFrame (Hint: use the read_csv() method).\nThe headers are a mess! Change the column names to be reasonable.\n\nHint: columns is a mutable attribute of the dataframe so df.columns = some_list_of_the_correct_length will assign new column names.\n\n\n\nIf you are only going the R route, do the above, but in R. (Hints Below.)\n\ndata &lt;- read.csv(‚Äúmy_data.csv‚Äù)"
  },
  {
    "objectID": "python_geospatial_basics.html#environment",
    "href": "python_geospatial_basics.html#environment",
    "title": "Python Lectures",
    "section": "",
    "text": "Before we get started we need to set up a Python environment in which to work. We will be using Anaconda for this.\n\nDownload the environment.yml\nIn the start menu search for Anaconda. Open an Anaconda Powershell.\n\ncd ~\nmkdir geog441\ncd geog441\ncp ~/Downloads/environment.yml .\nconda env create -f environment.yml\n\nFYI: What is this environment.yml thing?\nname: geo\nchannels:\n  - defaults\ndependencies: \n  - geopandas\n  - jupyterlab\n  - rioxarray\n  - tabulate\n  - tqdm\n\nUsing conda env create with the environment yaml creates a new conda environment named geo with the dependencies installed. Next we will activate the geo environment.\nconda activate geo\nNotice that the conda environment shown after the prompt has changed from (base) to (geo).\nIf later you find that you need another package you can add it to the environment (while in the environment) with conda install &lt;whatever_package&gt;.\nMore info on managing conda environments"
  },
  {
    "objectID": "python_geospatial_basics.html#starting-a-jupyter-lab",
    "href": "python_geospatial_basics.html#starting-a-jupyter-lab",
    "title": "Python Lectures",
    "section": "",
    "text": "jupyter lab\nThis will open a new jupyter lab in your browser. ## Using VScode\nRunning Jupyter in VScode offers some advantages (in my opinion). To do this you need to install the jupyter extension and the Python Extension. Then when you open a file with a .ipynb extension it will be treated as a Jupyter notebook."
  },
  {
    "objectID": "python_geospatial_basics.html#basic-python-data-types",
    "href": "python_geospatial_basics.html#basic-python-data-types",
    "title": "Python Lectures",
    "section": "",
    "text": "Type\nExample(s)\n\n\n\n\nString\n'Dude!'\n\n\nFloat\n1.2\n\n\nInt\n3\n\n\nTuple\n('x', 'y')(1, 2)('x', 3.2)\n\n\nList\n['x', 'y'][1, 2]Possible but bad ‚Äì&gt; ['x', 3.2]\n\n\nDict\n{'dogs': 26, 'cats', 100}\n\n\netc‚Ä¶\nthere are others"
  },
  {
    "objectID": "python_geospatial_basics.html#basic-numbers",
    "href": "python_geospatial_basics.html#basic-numbers",
    "title": "Python Lectures",
    "section": "",
    "text": "Floats and Ints don‚Äôt do anything all that surprising\n\na = 2 + 2\nb = 2.0 + 2.0\nc = a + b\n\n\nprint(f'a is an {type(a)}')\nprint(f'b is a {type(b)}')\nprint(f'c is a {type(c)}')\nprint(f'a / b is {a / b}')\nprint(f'5 / 4 is {5 / 4}')\nprint(f'but 5 // 4 is {5 // 4}')\nprint(f'and 5 % 4 is {5 % 4}')\n\na is an &lt;class 'int'&gt;\nb is a &lt;class 'float'&gt;\nc is a &lt;class 'float'&gt;\na / b is 1.0\n5 / 4 is 1.25\nbut 5 // 4 is 1\nand 5 % 4 is 1"
  },
  {
    "objectID": "python_geospatial_basics.html#sequences",
    "href": "python_geospatial_basics.html#sequences",
    "title": "Python Lectures",
    "section": "",
    "text": "Lists, tuples, and strings ae all sequences\n\n# a list\na_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# a tuple\na_tup = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n# a string\na_str = 'Wil je graag een neushorn?'\n\n# access by index\na = a_list[0]\nb = a_list[-1]\nc = a_list[4]\nprint(f'by index:\\n 0 --&gt; {a},\\n-1 --&gt; {b},\\n 4 --&gt; {c}')\n\n# works fro strings to\nprint('string item at 4 --&gt; ', a_str[4])\n\n# you can slice a list or tuple(remember 0 indexed)\nprint('\\nslices:')\nprint(a_list[2:5])\nprint(a_list[8:])\nprint(a_tup[2:5])\nprint(a_str[-9:])\n\nby index:\n 0 --&gt; 1,\n-1 --&gt; 9,\n 4 --&gt; 5\nstring item at 4 --&gt;  j\n\nslices:\n[3, 4, 5]\n[9]\n(3, 4, 5)\nneushorn?\n\n\nSlicing\nSequences tutorial\nSequence tutorial as video\nTHe key difference is that tuples are immutable.\n\na_list[1] = 256\n\na_tup[1] = 256\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[3], line 3\n      1 a_list[1] = 256\n----&gt; 3 a_tup[1] = 256\n\nTypeError: 'tuple' object does not support item assignment"
  },
  {
    "objectID": "python_geospatial_basics.html#dictionaries",
    "href": "python_geospatial_basics.html#dictionaries",
    "title": "Python Lectures",
    "section": "",
    "text": "pets = {'honden': 26, 'katten': 100}\n\nfor key, val in pets.items():\n  print(f'{val} {key}')\n\nprint(f'{pets[\"honden\"] + pets[\"katten\"]} huisdieren')\n\n26 honden\n100 katten\n126 huisdieren\n\n\nMore on dictionaries"
  },
  {
    "objectID": "python_geospatial_basics.html#iterating",
    "href": "python_geospatial_basics.html#iterating",
    "title": "Python Lectures",
    "section": "",
    "text": "a = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# use a loop to append squared values to new lists\nb = []\nfor n in a:\n  b.append(n**2)\n\n# or, better, use a comprehension\nc = [n**2 for n in a]\n\nprint(b)\nprint('is the same as')\nprint(c)\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\nis the same as\n[1, 4, 9, 16, 25, 36, 49, 64, 81]"
  },
  {
    "objectID": "python_geospatial_basics.html#functions",
    "href": "python_geospatial_basics.html#functions",
    "title": "Python Lectures",
    "section": "",
    "text": "Defined with def\nCan take arguments\ncan return something\nhave there own scope\n\n\nimport numpy as np\n\ndef root_mean_square(list_of_numbers):\n  rms = np.sqrt(\n    np.array([n**2 for n in list_of_numbers]).sum() /\n    len(list_of_numbers)\n    )\n\n  return rms\n\nl = [1.2, 3.3, 1.4, 1.4, 4.2]\nrms = root_mean_square(l)\n\nprint(rms)\n\n2.6034592372457075\n\n\nThey do nat have to have arguments or return stuff.\n\ndef complain():\n  print('This is boring!\\nwhen will we get to the GIS stuff.\\n\\U0001F620\\U0001F620\\U0001F620\\n\\nSoon! Bear with me.')\n\ncomplain()\n\nThis is boring!\nwhen will we get to the GIS stuff.\nüò†üò†üò†\n\nSoon! Bear with me."
  },
  {
    "objectID": "python_geospatial_basics.html#pandas-dataframe",
    "href": "python_geospatial_basics.html#pandas-dataframe",
    "title": "Python Lectures",
    "section": "",
    "text": "DataFrames hold tabular data\n\nfrom datetime import datetime, timedelta\nfrom random import uniform\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# some arbitrary time range \nstart_time = datetime(2025, 3, 1, 8, 0, 0)\nend_time = datetime(2025, 3, 3, 17, 0, 0)\ninterval = timedelta(minutes=30)\ntime_stamps = []\ncurrent_time = start_time\nwhile current_time &lt;= end_time:\n    time_stamps.append(current_time)\n    current_time += interval\n\n# some made up temperature data\ntemp_c = [\n  20 + uniform(-10, 10) + 10 *\n  np.sin(2 * np.pi * t.hour / 24)\n  for t\n  in time_stamps\n]\n\n# empty dataframe\ndf = pd.DataFrame()\n\n# add data\ndf['date_time'] = time_stamps\ndf['T (C)'] = temp_c\n\ndf.head()\n\n\n\n\n\n\n\n\ndate_time\nT (C)\n\n\n\n\n0\n2025-03-01 08:00:00\n32.275064\n\n\n1\n2025-03-01 08:30:00\n28.774465\n\n\n2\n2025-03-01 09:00:00\n21.673834\n\n\n3\n2025-03-01 09:30:00\n33.957310\n\n\n4\n2025-03-01 10:00:00\n26.920906"
  },
  {
    "objectID": "python_geospatial_basics.html#pandas-dataframe-cont.",
    "href": "python_geospatial_basics.html#pandas-dataframe-cont.",
    "title": "Python Lectures",
    "section": "",
    "text": "fig, ax = plt.subplots()\n\n# create the scatter plot\nplt.scatter(df.date_time, df['T (C)'], marker='x', color = 'k')\n\n# set the x-axis tick labels and rotate them\nplt.xticks(rotation=80, ha='right')\n\n# label axes\nplt.xlabel('Day and Time')\nplt.ylabel('Temperature (C)')\nplt.title('Hourly Temperature (C) in West Crabhammer')\n\n# adjust layout to prevent labels from overlapping\nplt.tight_layout()\n\n# Show the plot\nplt.show()\n\n\n\n\n\n\n\n\n\n# get the mean temperature over the timeseries\ndf['T (C)'].mean()\n\nnp.float64(19.81998889001604)\n\n\nWhen there are no spaces in a column name you can access the column as an attribute of the datafame.\n\n# get the number of time stamps in the date_time column\ndf.date_time.count()\n\nnp.int64(115)\n\n\nThere is a lot more to know about Pandas DataFrames. This is enough for us to move on to GeoPandas. I encourage you to learn more about Pandas as an exercise."
  },
  {
    "objectID": "python_geospatial_basics.html#homework",
    "href": "python_geospatial_basics.html#homework",
    "title": "Python Lectures",
    "section": "",
    "text": "If you are choosing Python as you language in this course (and what we have covered today is not a peace of cake for you already), create a jupyter notebook and do the following:\n\n\nDownload the results from the class survey from here as a csv file.\nRead the csv into a Pandas DataFrame (Hint: use the read_csv() method).\nThe headers are a mess! Change the column names to be reasonable.\n\nHint: columns is a mutable attribute of the dataframe so df.columns = some_list_of_the_correct_length will assign new column names.\n\n\n\nIf you are only going the R route, do the above, but in R. (Hints Below.)\n\ndata &lt;- read.csv(‚Äúmy_data.csv‚Äù)"
  },
  {
    "objectID": "python_geospatial_basics.html#geopandas",
    "href": "python_geospatial_basics.html#geopandas",
    "title": "Python Lectures",
    "section": "Geopandas",
    "text": "Geopandas\n&lt;‚Äìimg width=‚Äú560‚Äù height=‚Äú315‚Äù src=‚Äúimages/pandas.png‚Äù&gt;&lt;‚Äì/img&gt; g e o p a n d a s"
  },
  {
    "objectID": "python_geospatial_basics.html#vector-data",
    "href": "python_geospatial_basics.html#vector-data",
    "title": "Python Lectures",
    "section": "Vector Data",
    "text": "Vector Data\n\nMost often we will interact with vector data using GeoPandas\n\nGeoPandas is an extension of Pandas.\nIt uses Fiona, which in-turn relies on GDAL and OGR, to read and write.\nVector data is handled by the Shapely module, which relies on GEOS.\nGEOS implements the OGC Simple Features geometry\n\nProjections are managed by pyproj which is built upon PROJ"
  },
  {
    "objectID": "python_geospatial_basics.html#shapely",
    "href": "python_geospatial_basics.html#shapely",
    "title": "Python Lectures",
    "section": "Shapely",
    "text": "Shapely\n\nShapely Geometric Objects consist of coordinate tuples:\n\nPoint - (x, y) or three dimensional (x, y, z), e.g.¬†Point(5.2, 52.1)\nLineString - List if coordinates of vertices, e.g.¬†LineString([(0, 0), (1, 2)])\nPolygon - Basically a closed linestring, e.g.¬†Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))\nNotice that the first and last coord of the Polygon are the same.\nMore on Shapely geometries"
  },
  {
    "objectID": "python_geospatial_basics.html#polygon",
    "href": "python_geospatial_basics.html#polygon",
    "title": "Python Lectures",
    "section": "Polygon",
    "text": "Polygon\n\nfrom shapely import Polygon\n\ncoords = ((0., 0.), (0., 2.), (1., 1.), (1., 0.), (0., 0.))\np = Polygon(coords)\n\nc = p.exterior.coords\n\nprint(c[0] == c[-1])\np\n\nTrue"
  },
  {
    "objectID": "python_geospatial_basics.html#reading-files",
    "href": "python_geospatial_basics.html#reading-files",
    "title": "Python Lectures",
    "section": "Reading Files",
    "text": "Reading Files\nHere we will read a geojson using the read_file method.\n\nfrom pathlib import Path\nimport geopandas as gpd\n\n# path to data\ndata_dir = Path('data')\ngeojson = data_dir / 'upper_santa_rita_creek.geojson'\n\n# open the geojson\ngdf = gpd.read_file(geojson)\n\ngdf\n\n\n\n\n\n\n\n\nid\ngeometry\n\n\n\n\n0\nglobalwatershedpoint\nPOINT (-120.80331 35.52537)\n\n\n1\nglobalwatershed\nPOLYGON ((-120.81096 35.50944, -120.81161 35.5..."
  }
]