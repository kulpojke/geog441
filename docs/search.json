[
  {
    "objectID": "intro.html#section",
    "href": "intro.html#section",
    "title": "",
    "section": "",
    "text": "Today we will cover a few of the tools we will be using this quarter, which should hopefully be installed.\n+ git\n+ conda\n+ VScode\n+ Rstudio\n+ QGIS\n+ GDAL"
  },
  {
    "objectID": "python_geospatial_basics.html#environment",
    "href": "python_geospatial_basics.html#environment",
    "title": "Python Lectures",
    "section": "Environment",
    "text": "Environment\nBefore we get started we need to set up a Python environment in which to work. We will be using Anaconda for this. It should already be installed on the lab computers. If you are using your own computer\n\nDownload the environment.yml\nIf you are working on a lab computer In the start menu search for Anaconda. Open an Anaconda Powershell. (on linux or mac with Anconda or miniconda or Mamba installed just open a terminal)(If you are installing on your own computer I recommend Mamba)\n\ncd ~\nmkdir geog441\ncd geog441\ncp ~/Downloads/environment.yml .\nconda env create -f environment.yml\nWhat is this environment.yml thing?\nname: geo\nchannels:\n  - defaults\ndependencies: \n  - geopandas\n  - jupyterlab\n  - rioxarray\n  - tabulate\n  - tqdm\nUsing conda env create with the environment yaml creates a new conda environment named geo with the dependencies installed. Next we will activate the geo environment.\nconda activate geo\nNotice that the conda environment shown after the prompt has changed from (base) to (geo).\nIf later you find that you need another package you can add it to the environment (while in the environment) with conda install &lt;whatever_package&gt;.\nMore info on managing conda environments"
  },
  {
    "objectID": "python_geospatial_basics.html#starting-a-jupyter-lab",
    "href": "python_geospatial_basics.html#starting-a-jupyter-lab",
    "title": "Python Lectures",
    "section": "Starting a Jupyter Lab",
    "text": "Starting a Jupyter Lab\njupyter lab\nThis will open a new jupyter lab in your browser."
  },
  {
    "objectID": "python_geospatial_basics.html#using-vscode",
    "href": "python_geospatial_basics.html#using-vscode",
    "title": "Python Lectures",
    "section": "Using VScode",
    "text": "Using VScode\nRunning Jupyter in VScode offers some advantages (in my opinion). To do this you need to install the jupyter extension and the Python Extension. Then when you open a file with a .ipynb extension it will be treated as a Jupyter notebook."
  },
  {
    "objectID": "python_geospatial_basics.html#basic-python-data-types",
    "href": "python_geospatial_basics.html#basic-python-data-types",
    "title": "Python Lectures",
    "section": "Basic Python data types",
    "text": "Basic Python data types\n\n\n\n\n\n\n\nType\nExample(s)\n\n\n\n\nString\n'Dude!'\n\n\nFloat\n1.2\n\n\nInt\n3\n\n\nTuple\n('x', 'y')(1, 2)('x', 3.2)\n\n\nList\n['x', 'y'][1, 2]Possible but bad â€“&gt; ['x', 3.2]\n\n\nDict\n{'dogs': 26, 'cats', 100}\n\n\netcâ€¦\nthere are others"
  },
  {
    "objectID": "python_geospatial_basics.html#basic-numbers",
    "href": "python_geospatial_basics.html#basic-numbers",
    "title": "Python Lectures",
    "section": "Basic Numbers",
    "text": "Basic Numbers\nFloats and Ints donâ€™t do anything all that surprising\n\n\na = 2 + 2\nb = 2.0 + 2.0\nc = a + b\n\n\nprint(f'a is an {type(a)}')\nprint(f'b is a {type(b)}')\nprint(f'c is a {type(c)}')\nprint(f'a / b is {a / b}')\nprint(f'5 / 4 is {5 / 4}')\nprint(f'but 5 // 4 is {5 // 4}')\nprint(f'and 5 % 4 is {5 % 4}')\n\n\na is an &lt;class 'int'&gt;\nb is a &lt;class 'float'&gt;\nc is a &lt;class 'float'&gt;\na / b is 1.0\n5 / 4 is 1.25\nbut 5 // 4 is 1\nand 5 % 4 is 1"
  },
  {
    "objectID": "python_geospatial_basics.html#exercise---basic-numbers",
    "href": "python_geospatial_basics.html#exercise---basic-numbers",
    "title": "Python Lectures",
    "section": "Exercise - Basic Numbers",
    "text": "Exercise - Basic Numbers\nTry the following, print the results, see what they do.\n\n\na = 5 // 4\nb = 5 % 4\nc = a + b"
  },
  {
    "objectID": "python_geospatial_basics.html#sequences",
    "href": "python_geospatial_basics.html#sequences",
    "title": "Python Lectures",
    "section": "Sequences",
    "text": "Sequences\nLists, tuples, and strings ae all sequences\n\n\n# a list\na_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# a tuple\na_tup = (1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n# a string\na_str = 'Wil je graag een neushorn?'\n\n# access by index\na = a_list[0]\nb = a_list[-1]\nc = a_list[4]\nprint(f'by index:\\n 0 --&gt; {a},\\n-1 --&gt; {b},\\n 4 --&gt; {c}')\n\n# works fro strings to\nprint('string item at 4 --&gt; ', a_str[4])\n\n# you can slice a list or tuple(remember 0 indexed)\nprint('\\nslices:')\nprint(a_list[2:5])\nprint(a_list[8:])\nprint(a_tup[2:5])\nprint(a_str[-9:])\n\n\nby index:\n 0 --&gt; 1,\n-1 --&gt; 9,\n 4 --&gt; 5\nstring item at 4 --&gt;  j\n\nslices:\n[3, 4, 5]\n[9]\n(3, 4, 5)\nneushorn?\n\n\nSlicing\nSequences tutorial\nSequence tutorial as video"
  },
  {
    "objectID": "python_geospatial_basics.html#exercise---lists-and-tuples",
    "href": "python_geospatial_basics.html#exercise---lists-and-tuples",
    "title": "Python Lectures",
    "section": "Exercise - Lists and Tuples",
    "text": "Exercise - Lists and Tuples\nThe key between lists and tuples is that tuples are immutable. Try assigning a value to both of the following.\n\n\n# a list\na_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# a tuple\na_tup = (1, 2, 3, 4, 5, 6, 7, 8, 9)"
  },
  {
    "objectID": "python_geospatial_basics.html#dictionaries",
    "href": "python_geospatial_basics.html#dictionaries",
    "title": "Python Lectures",
    "section": "Dictionaries",
    "text": "Dictionaries\n\n\npets = {'honden': 26, 'katten': 100}\n\nfor key, val in pets.items():\n  print(f'{val} {key}')\n\nprint(f'{pets[\"honden\"] + pets[\"katten\"]} huisdieren')\n\n\n26 honden\n100 katten\n126 huisdieren\n\n\nMore on dictionaries"
  },
  {
    "objectID": "python_geospatial_basics.html#iterating",
    "href": "python_geospatial_basics.html#iterating",
    "title": "Python Lectures",
    "section": "Iterating",
    "text": "Iterating\n\n\na = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# use a loop to append squared values to new lists\nb = []\nfor n in a:\n  b.append(n**2)\n\n# or, better, use a comprehension\nc = [n**2 for n in a]\n\nprint(b)\nprint('is the same as')\nprint(c)\n\n\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\nis the same as\n[1, 4, 9, 16, 25, 36, 49, 64, 81]"
  },
  {
    "objectID": "python_geospatial_basics.html#exercise---iterating",
    "href": "python_geospatial_basics.html#exercise---iterating",
    "title": "Python Lectures",
    "section": "Exercise - Iterating",
    "text": "Exercise - Iterating\nYou can nest loops.\n\n\nnumbers = []\nfor i in range(3):\n  for j in range(3):\n    numbers.append((i, j))\n\nnumbers\n\n\n[(0, 0), (0, 1), (0, 2), (1, 0), (1, 1), (1, 2), (2, 0), (2, 1), (2, 2)]\n\n\n\nRecreate the above with a list comprehension.\nreplace the square brackets in this list comprehension, = [n**2 for n in a], with parenthesis.\nCan you create a dictionary with a comprehension."
  },
  {
    "objectID": "python_geospatial_basics.html#functions",
    "href": "python_geospatial_basics.html#functions",
    "title": "Python Lectures",
    "section": "Functions",
    "text": "Functions\n\nDefined with def\nCan take arguments\ncan return something\nhave there own scope\n\n\n\nimport numpy as np\n\ndef root_mean_square(list_of_numbers):\n  rms = np.sqrt(\n    np.array([n**2 for n in list_of_numbers]).sum() /\n    len(list_of_numbers)\n    )\n\n  return rms\n\nl = [1.2, 3.3, 1.4, 1.4, 4.2]\nrms = root_mean_square(l)\n\nprint(rms)\n\n\n2.6034592372457075\n\n\nThey do not have to have arguments or return stuff.\n\n\ndef complain():\n  print('This is boring!\\nwhen will we get to the GIS stuff.\\n\\U0001F620\\U0001F620\\U0001F620\\n\\nSoon! Bear with me.')\n\ncomplain()\n\n\nThis is boring!\nwhen will we get to the GIS stuff.\nðŸ˜ ðŸ˜ ðŸ˜ \n\nSoon! Bear with me.\n\n\nPython is an object oriented programming language. Everything that you can assign to a variable (which is almost everything) can be though of as an object, for example, built in functions are objects.\n\n\nzzz = print\nzzz('toenails')\n\n\ntoenails\n\n\nMany objects have built in functions as an attribute, these are called methods. For instance, strings have a method called split (they have many other methods as well).\n\n\ns = 'hyphens-are-everywhere-they-haunt-me-in-my-dreams'\ns.split('-')\n\n\n['hyphens', 'are', 'everywhere', 'they', 'haunt', 'me', 'in', 'my', 'dreams']\n\n\nWe will encounter heaps of methods later."
  },
  {
    "objectID": "python_geospatial_basics.html#exercise---functions",
    "href": "python_geospatial_basics.html#exercise---functions",
    "title": "Python Lectures",
    "section": "Exercise - Functions",
    "text": "Exercise - Functions\nUse a function and a list comprehension to reproduce the results of the for loop below:\n\n\nl = [(4, 3, 2), (2, 2, 2), (1, 2, 3)]\n\nresults = []\n\nfor t in l:\n  results.append(\n    t[0] + t[1] - t[2] +\n    (t[0] * t[1] + t[2])**t[1] /\n    (t[1]**2 * 5**t[0])\n  )\n\nresults\n\n\n[5.487822222222222, 2.36, 1.25]\n\n\nTake some time to contemplate, what is this?\n\n\nimport numpy as np\n\nnested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n\nnp.array(nested_list)\n\n\narray([[1, 2, 3],\n       [4, 5, 6],\n       [7, 8, 9]])\n\n\nBTW, you can import a library as anything you want\n\n\nimport numpy as frogz_on_crack\n\nfrogz_on_crack.array([1, 2, 3]) \n\n\narray([1, 2, 3])\n\n\nWhy would one avoid doing this kind of thing?\nYou can also dump all of the objects from a module into the main namespace\n\n\n# from numpy import everything\nfrom numpy import *\n\narray([1, 2, 3 ])\n\n\narray([1, 2, 3])\n\n\nWhy is this a bad practice?"
  },
  {
    "objectID": "python_geospatial_basics.html#pandas-dataframe",
    "href": "python_geospatial_basics.html#pandas-dataframe",
    "title": "Python Lectures",
    "section": "Pandas DataFrame",
    "text": "Pandas DataFrame\nDataFrames hold tabular data. Here we will read a csv file as a DataFrame and mess with it.\n\nThis cell just downloads the file from a url. Take a few minutes and see if you can change it to be generally useful by allowing the url and save location to be specified as arguments. Hint, you need to change very little, and you donâ€™t really need to know how the function works in any detail.\n\n\n\nimport requests\nfrom pathlib import Path\n\ndef get_NZ_file():\n  '''\n  A purposefully bad function to download one specific file.\n  '''\n  # url to Dec 2024 NZ GH emissions by industry (long url!)\n  url = 'https://www.stats.govt.nz/assets/Uploads/Greenhouse-gas-emissions-industry-and-household/Greenhouse-gas-emissions-industry-and-household-December-2024-quarter/Download-data/greenhouse-gas-emissions-industry-and-household-december-2024-quarter.csv'\n  # make a dir for data, if does not exist\n  save_dir = Path.cwd() / 'data'\n  save_dir.mkdir(exist_ok=True)\n  # get file name\n  basename = url.split('/')[-1]\n  # and a directory to save to \n  save_path = save_dir / basename\n\n  try:\n      response = requests.get(url, stream=True)\n      # raise HTTPError for bad responses (4xx or 5xx)\n      response.raise_for_status() \n      with open(save_path, 'wb') as file:\n        for chunk in response.iter_content(chunk_size=8192):\n          file.write(chunk)\n      print(f\"File downloaded successfully to {save_path}\")\n\n  except requests.exceptions.RequestException as e:\n    print(f'An error occurred: {e}')\n  except Exception as e:\n    print(f'An unexpected error occurred: {e}')\n\n  return save_path\n\nfile_path = get_NZ_file()\n\n\nFile downloaded successfully to /home/michael/CP/geog441/data/greenhouse-gas-emissions-industry-and-household-december-2024-quarter.csv\n\n\n\nRead the csv, and look at the head (first few rows). Notice that there are column names, and on the left side there is a numerical index.\n\n\n\nimport pandas as pd\n\ndf = pd.read_csv(file_path)\ndf.head()\n\n\n\n\n\n\n\n\n\nAnzsic\nAnzsic_descriptor\nGas\nPeriod\nData_value\nVariable\nUnits\nMagnitude\n\n\n\n\n0\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.03\n10875\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n1\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.06\n11003\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n2\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.09\n10993\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n3\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.12\n10914\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n4\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2011.03\n11014\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n\n\n\n\n\nWe can also see the last few rows if we want.\n\n\ndf.tail()\n\n\n\n\n\n\n\n\n\nAnzsic\nAnzsic_descriptor\nGas\nPeriod\nData_value\nVariable\nUnits\nMagnitude\n\n\n\n\n4795\nZZZ\nTotal\nNitrous oxide\n2023.12\n1708\nActual\nKilotonnes\nCarbon dioxide equivalents\n\n\n4796\nZZZ\nTotal\nNitrous oxide\n2024.03\n1615\nActual\nKilotonnes\nCarbon dioxide equivalents\n\n\n4797\nZZZ\nTotal\nNitrous oxide\n2024.06\n1482\nActual\nKilotonnes\nCarbon dioxide equivalents\n\n\n4798\nZZZ\nTotal\nNitrous oxide\n2024.09\n1652\nActual\nKilotonnes\nCarbon dioxide equivalents\n\n\n4799\nZZZ\nTotal\nNitrous oxide\n2024.12\n1662\nActual\nKilotonnes\nCarbon dioxide equivalents\n\n\n\n\n\n\n\nOr we can slice from the middle using index slicing, just like with a list.\n\n\ndf[100:105]\n\n\n\n\n\n\n\n\n\nAnzsic\nAnzsic_descriptor\nGas\nPeriod\nData_value\nVariable\nUnits\nMagnitude\n\n\n\n\n100\nBB1\nMining\nCarbon dioxide equivalents\n2020.03\n307\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n101\nBB1\nMining\nCarbon dioxide equivalents\n2020.06\n256\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n102\nBB1\nMining\nCarbon dioxide equivalents\n2020.09\n280\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n103\nBB1\nMining\nCarbon dioxide equivalents\n2020.12\n271\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n104\nBB1\nMining\nCarbon dioxide equivalents\n2021.03\n276\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n\n\n\n\n\nThere are many other ways to select from Pandas DataFrames.\nThe Period column gives dates, but they are in a format that will be interpreted as floats (e.g.Â 20007.08). Here we change them to datetimes and use them to set the index, giving us a DateTime index.\nEarlier we mentioned methods, and we saw that strings have method split() which splits the string. Columns in Pandas that are of the type str, that is to say string, have all of the same methods under an attribute called str.\nThis cell uses many methods strung together to change the Period column to DateTime format and set the index.\n\n\ndf.index = pd.to_datetime(\n  df.Period.astype('str').str.split('.').str.join('-')\n)\n\ndf.head()\n\n\n\n\n\n\n\n\n\nAnzsic\nAnzsic_descriptor\nGas\nPeriod\nData_value\nVariable\nUnits\nMagnitude\n\n\nPeriod\n\n\n\n\n\n\n\n\n\n\n\n\n2010-03-01\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.03\n10875\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n2010-06-01\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.06\n11003\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n2010-09-01\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.09\n10993\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n2010-12-01\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2010.12\n10914\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n2011-03-01\nAAZ\nAgriculture, forestry, fishing\nCarbon dioxide equivalents\n2011.03\n11014\nSeasonally adjusted\nKilotonnes\nCarbon dioxide equivalents\n\n\n\n\n\n\n\nSee what gasses are measured by looking at unique vlaues in the Gas column.\n\n\ndf.Gas.unique()\n\n\narray(['Carbon dioxide equivalents', 'Methane', 'Carbon dioxide',\n       'Fluorinated gases', 'Nitrous oxide'], dtype=object)\n\n\n\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots(1)\n\ndf[(df.index.month == 6) &\n  (df.Gas == 'Nitrous oxide') &\n  (df.Anzsic == 'ZZZ')\n].plot.scatter('Period', 'Data_value', ax=ax)\nax.set_title('NZ June Nitrous Oxide Emissions')\nax.set_ylabel('Kilotonnes')\nax.set_xlabel('Year')\n\n\nText(0.5, 0, 'Year')"
  },
  {
    "objectID": "python_geospatial_basics.html#pandas-dataframe-cont.",
    "href": "python_geospatial_basics.html#pandas-dataframe-cont.",
    "title": "Python Lectures",
    "section": "Pandas DataFrame Cont.",
    "text": "Pandas DataFrame Cont.\nThere is a lot more to know about Pandas DataFrames. This is enough for us to move on to GeoPandas. I encourage you to learn more about Pandas as an exercise."
  },
  {
    "objectID": "python_geospatial_basics.html#geopandas",
    "href": "python_geospatial_basics.html#geopandas",
    "title": "Python Lectures",
    "section": "Geopandas",
    "text": "Geopandas"
  },
  {
    "objectID": "python_geospatial_basics.html#vector-data",
    "href": "python_geospatial_basics.html#vector-data",
    "title": "Python Lectures",
    "section": "Vector Data",
    "text": "Vector Data\n\nMost often we will interact with vector data using GeoPandas\n\nGeoPandas is an extension of Pandas.\nIt uses Fiona, which in-turn relies on GDAL and OGR, to read and write.\nVector data is handled by the Shapely module, which relies on GEOS.\nGEOS implements the OGC Simple Features geometry\n\nProjections are managed by pyproj which is built upon PROJ"
  },
  {
    "objectID": "python_geospatial_basics.html#shapely",
    "href": "python_geospatial_basics.html#shapely",
    "title": "Python Lectures",
    "section": "Shapely",
    "text": "Shapely\n\nShapely Geometric Objects consist of coordinate tuples:\n\nPoint - (x, y) or three dimensional (x, y, z), e.g.Â Point(5.2, 52.1)\nLineString - List if coordinates of vertices, e.g.Â LineString([(0, 0), (1, 2)])\nPolygon - Basically a closed linestring, e.g.Â Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))\nNotice that the first and last coord of the Polygon are the same.\nMore on Shapely geometries"
  },
  {
    "objectID": "python_geospatial_basics.html#polygon",
    "href": "python_geospatial_basics.html#polygon",
    "title": "Python Lectures",
    "section": "Polygon",
    "text": "Polygon\n\n\nfrom shapely import Polygon\n\ncoords = ((0., 0.), (0., 2.), (1., 1.), (1., 0.), (0., 0.))\np = Polygon(coords)\n\nc = p.exterior.coords\n\nprint(c[0] == c[-1])\np\n\n\nTrue"
  },
  {
    "objectID": "python_geospatial_basics.html#reading-files",
    "href": "python_geospatial_basics.html#reading-files",
    "title": "Python Lectures",
    "section": "Reading Files",
    "text": "Reading Files\nHere we will read a geojson using the read_file method.\n\n\nfrom pathlib import Path\nimport geopandas as gpd\n\n# path to data\ndata_dir = Path('data')\ngeojson = data_dir / 'upper_santa_rita_creek.geojson'\n\n# open the geojson\ngdf = gpd.read_file(geojson)\n\ngdf\n\n\n\n\n\n\n\n\n\nid\ngeometry\n\n\n\n\n0\nglobalwatershedpoint\nPOINT (-120.80331 35.52537)\n\n\n1\nglobalwatershed\nPOLYGON ((-120.81096 35.50944, -120.81161 35.5..."
  }
]