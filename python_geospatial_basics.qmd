---
title: 'Python Lectures'
format:
  revealjs:
    incremental: false
    scrollable: true
    smaller: true
jupyter: python3
echo: true
output-location: column
navigation-mode: vertical
df-print: kable

---

# Introducing Python

+ It allows for more flexibility than a GUI based GIS program.
+ Other GIS applications (e.g. QGIS, ArcGIS, postGIS) often have a Python interface.
+ generally a widely used language.

## Environment {.scrollable .smaller .non-incremental}

Before we get started we need to set up a Python environment in which to work.  We will be using Anaconda for this.  It _should_ already be installed on the lab computers.  If you are using your own computer  

+ Download the environment.yml
+ If you are working on a lab computer In the start menu search for Anaconda. Open an Anaconda Powershell.  (on linux or mac with Anconda or miniconda or Mamba installed just open a terminal)(If you are installing on your own computer I recommend [Mamba](https://mamba.readthedocs.io/en/latest/installation/mamba-installation.html))


``` {bash}
cd ~
mkdir geog441
cd geog441
cp ~/Downloads/environment.yml .
conda env create -f environment.yml
```


What is this _environment.yml_ thing?  
``` {yml}
name: geo
channels:
  - defaults
dependencies: 
  - geopandas
  - jupyterlab
  - rioxarray
  - tabulate
  - tqdm
```


Using `conda env create` with the environment yaml creates a new conda environment named _geo_ with the dependencies installed.  Next we will activate the _geo_ environment.

``` {bash}
conda activate geo
```

Notice that the conda environment shown after the prompt has changed from `(base)` to `(geo)`.

If later you find that you need another package you can add it to the environment (while in the environment) with `conda install <whatever_package>`.

[More info on managing conda environments](https://docs.conda.io/projects/conda/en/4.6.0/user-guide/tasks/manage-environments.html#creating-an-environment-from-an-environment-yml-file)

## Starting a Jupyter Lab

``` {bash}
jupyter lab
```
This will open a new jupyter lab in your browser.  

## Using VScode

Running Jupyter in VScode offers some advantages (in my opinion).  To do  this you need to install the jupyter extension and the Python Extension. Then when you open a file with a .ipynb extension it will be treated as a Jupyter notebook.


## Basic Python data types {.scrollable}

| Type   | Example(s) |
|--------|---------|
| String | `'Dude!'`|
| Float  | `1.2`  |
| Int    | `3` |
| Tuple  | `('x', 'y')`<br>`(1, 2)`<br>`('x', 3.2)` |
| List   | `['x', 'y']`<br>`[1, 2]`<br>Possible but bad --> `['x', 3.2]` |
| Dict   | `{'dogs': 26, 'cats', 100}` |
| etc... | there are others |


## Basic Numbers

Floats and Ints don't do anything all that surprising

```{python}
a = 2 + 2
b = 2.0 + 2.0
c = a + b


print(f'a is an {type(a)}')
print(f'b is a {type(b)}')
print(f'c is a {type(c)}')
print(f'a / b is {a / b}')
print(f'5 / 4 is {5 / 4}')
print(f'but 5 // 4 is {5 // 4}')
print(f'and 5 % 4 is {5 % 4}')
```

## Exercise - Basic Numbers {background="#FF007F"}

Try the following, print the results, see what they do.
```{python}
a = 5 // 4
b = 5 % 4
c = a + b
```


## Sequences
Lists, tuples, and strings ae all sequences
```{python}
# a list
a_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# a tuple
a_tup = (1, 2, 3, 4, 5, 6, 7, 8, 9)

# a string
a_str = 'Wil je graag een neushorn?'

# access by index
a = a_list[0]
b = a_list[-1]
c = a_list[4]
print(f'by index:\n 0 --> {a},\n-1 --> {b},\n 4 --> {c}')

# works fro strings to
print('string item at 4 --> ', a_str[4])

# you can slice a list or tuple(remember 0 indexed)
print('\nslices:')
print(a_list[2:5])
print(a_list[8:])
print(a_tup[2:5])
print(a_str[-9:])
```

[Slicing](https://www.geeksforgeeks.org/python-list-slicing/#)  
[Sequences tutorial](https://labex.io/tutorials/python-how-to-manipulate-list-sequences-in-python-419858)  
[Sequence tutorial as video](https://www.youtube.com/watch?v=n3KMrwmq_94)

## Exercise - Lists and Tuples {background="#FF007F"}

The key between lists and tuples is that tuples are immutable.  Try assigning a value to both of the following.
```{python}
# a list
a_list = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# a tuple
a_tup = (1, 2, 3, 4, 5, 6, 7, 8, 9)
```


## Dictionaries

```{python}
pets = {'honden': 26, 'katten': 100}

for key, val in pets.items():
  print(f'{val} {key}')

print(f'{pets["honden"] + pets["katten"]} huisdieren')
```

[More on dictionaries](https://www.w3schools.com/python/python_dictionaries.asp)

## Iterating

```{python}
a = [1, 2, 3, 4, 5, 6, 7, 8, 9]

# use a loop to append squared values to new lists
b = []
for n in a:
  b.append(n**2)

# or, better, use a comprehension
c = [n**2 for n in a]

print(b)
print('is the same as')
print(c)

```

## Exercise - Iterating {background="#FF007F"}
You can nest loops.
``` {python}
numbers = []
for i in range(3):
  for j in range(3):
    numbers.append((i, j))

numbers
```

+ Recreate the above with a list comprehension.
+ replace the square brackets in this list comprehension, ` = [n**2 for n in a]`,  with parenthesis.
+ Can you create a dictionary with a comprehension.

## Functions {.scrollable .smaller .non-incremental}

+ Defined with def
+ Can take arguments
+ can return something
+ have there own scope
```{python}
import numpy as np

def root_mean_square(list_of_numbers):
  rms = np.sqrt(
    np.array([n**2 for n in list_of_numbers]).sum() /
    len(list_of_numbers)
    )

  return rms

l = [1.2, 3.3, 1.4, 1.4, 4.2]
rms = root_mean_square(l)

print(rms)

```

They do not have to have arguments or return stuff.

```{python}
def complain():
  print('This is boring!\nwhen will we get to the GIS stuff.\n\U0001F620\U0001F620\U0001F620\n\nSoon! Bear with me.')

complain()
```

Python is an _object oriented_ programming language.  Everything that you can assign to a variable (which is almost everything) can be though of as an object, for example, built in functions are objects.

```{python}
zzz = print
zzz('toenails')
```

Many objects have built in functions as an attribute, these are called methods.  For instance, strings have a method called split (they have many other methods as well).

```{python}
s = 'hyphens-are-everywhere-they-haunt-me-in-my-dreams'
s.split('-')
```

We will encounter heaps of methods later.

## Exercise - Functions {background="#FF007F"}

Use a function and a list comprehension to reproduce the results of the for loop below:
```{python}
l = [(4, 3, 2), (2, 2, 2), (1, 2, 3)]

results = []

for t in l:
  results.append(
    t[0] + t[1] - t[2] +
    (t[0] * t[1] + t[2])**t[1] /
    (t[1]**2 * 5**t[0])
  )

results
```

Take some time to contemplate, what is this?

```{python}
import numpy as np

nested_list = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

np.array(nested_list)
```

BTW, you can import a library as anything you want

```{python}
import numpy as frogz_on_crack

frogz_on_crack.array([1, 2, 3]) 
```

Why would one avoid doing this kind of thing?

You can also dump all of the objects from a module into the main namespace
```{python}
# from numpy import everything
from numpy import *

array([1, 2, 3 ])

```

Why is this a bad practice? What Is a namespace

```{python}
x = 'I love \U0001F30D'

def print_wrapper():
    print(x)

def print_poo():
    x = 'This is the value of x within the function'
    print(x)

print_wrapper()
print_poo()

print(x)

```

## Pandas DataFrame {.smaller}
DataFrames hold tabular data.  Here we will read a csv file as a DataFrame and mess with it.

1) This cell just downloads the file from a url.  __Take a few minutes and see if you can change it to be generally useful__ by allowing the url and save location to be specified as arguments. Hint, you need to change very little, and you don't really need to know how the function works in any detail.

```{python}
import requests
from pathlib import Path

def get_NZ_file():
  '''
  A purposefully bad function to download one specific file.
  '''
  # url to Dec 2024 NZ GH emissions by industry (long url!)
  url = 'https://www.stats.govt.nz/assets/Uploads/Greenhouse-gas-emissions-industry-and-household/Greenhouse-gas-emissions-industry-and-household-December-2024-quarter/Download-data/greenhouse-gas-emissions-industry-and-household-december-2024-quarter.csv'
  # make a dir for data, if does not exist
  save_dir = Path.cwd() / 'data'
  save_dir.mkdir(exist_ok=True)
  # get file name
  basename = url.split('/')[-1]
  # and a directory to save to 
  save_path = save_dir / basename

  try:
      response = requests.get(url, stream=True)
      # raise HTTPError for bad responses (4xx or 5xx)
      response.raise_for_status() 
      with open(save_path, 'wb') as file:
        for chunk in response.iter_content(chunk_size=8192):
          file.write(chunk)
      print(f"File downloaded successfully to {save_path}")

  except requests.exceptions.RequestException as e:
    print(f'An error occurred: {e}')
  except Exception as e:
    print(f'An unexpected error occurred: {e}')

  return save_path

file_path = get_NZ_file()
```

2) Read the csv, and look at the head (first few rows).  Notice that there are column names, and on the left side there is a numerical index.

```{python}
import pandas as pd

df = pd.read_csv(file_path)
df.head()
```

We can also see the last few rows if we want.

```{python}
df.tail()
```

Or we can slice from the middle using index slicing, just like with a list.

```{python}
df[100:105]
```

There are many other [ways to select from Pandas DataFrames](https://pandas.pydata.org/docs/getting_started/intro_tutorials/03_subset_data.html).   

The `Period` column gives dates, but they are in a format that will be interpreted as floats (e.g. 20007.08).  Here we change them to datetimes and use them to set the index, giving us a DateTime index.  

Earlier we mentioned methods, and we saw that strings have method `split()` which splits the string.  Columns in Pandas that are of the type `str`, that is to say string, have all of the same methods under an attribute called `str`.

This cell uses many methods strung together to change the Period column to DateTime format and set the index.

```{python}
df.index = pd.to_datetime(
  df.Period.astype('str').str.split('.').str.join('-')
)

df.head()
```

See what gasses are measured by looking at unique values in the Gas column.

```{python}
df.Gas.unique()
```

```{python}
import matplotlib.pyplot as plt

fig, ax = plt.subplots(1)

df[(df.index.month == 6) &
  (df.Gas == 'Nitrous oxide') &
  (df.Anzsic == 'ZZZ')
].plot.scatter('Period', 'Data_value', ax=ax)
ax.set_title('NZ June Nitrous Oxide Emissions')
ax.set_ylabel('Kilotonnes')
ax.set_xlabel('Year')
```



## Pandas DataFrame Cont. {.scrollable}


There is a lot more to know about Pandas DataFrames.  This is enough for us to move on to GeoPandas.  I encourage you to [learn more about Pandas](https://pandas.pydata.org/docs/user_guide/10min.html) as an exercise.




# Exploring Vector Data with  Geopandas {background-image="images/pandas.png"}

## Geopandas {background-image="images/pandas.png"}

## Vector Data {.smaller}

+ Most often we will interact with vector data using [GeoPandas](https://geopandas.org/en/stable/)  
  + GeoPandas is an extension of [Pandas](https://pandas.pydata.org/).
  + It uses Fiona, which in-turn relies on [GDAL and OGR](https://gdal.org/en/stable/), to read and write.
  + Vector data is handled by the [Shapely](http://toblerity.org/shapely/manual.html) module, which relies on [GEOS](https://libgeos.org/).
  + GEOS  implements the [OGC](https://en.wikipedia.org/wiki/Open_Geospatial_Consortium) [Simple Features geometry](https://en.wikipedia.org/wiki/Simple_Features)
+ Projections are managed by [pyproj](https://pyproj4.github.io/pyproj/stable/) which is built upon [PROJ](https://proj.org/en/stable/)


## Shapely {.smaller}

+ Shapely Geometric Objects consist of coordinate tuples:
  + Point - (x, y) or three dimensional (x, y, z), e.g. `Point(5.2, 52.1)`
  + LineString - List if coordinates of vertices, e.g.  `LineString([(0, 0), (1, 2)])`
  + Polygon - Basically a closed linestring, e.g.  `Polygon(((0., 0.), (0., 1.), (1., 1.), (1., 0.), (0., 0.)))` 
  + Notice that the first and last coord of the Polygon are the same.
  + More on [Shapely geometries](https://shapely.readthedocs.io/en/stable/geometry.html)

## Polygon
```{python}
from shapely import Polygon

coords = ((0., 0.), (0., 2.), (1., 1.), (1., 0.), (0., 0.))
p = Polygon(coords)

c = p.exterior.coords

print(c[0] == c[-1])
p
```


## Reading Files

Here we will read a geojson using the `read_file` method.
```{python}
from pathlib import Path
import geopandas as gpd

# path to data
data_dir = Path('data')
geojson = data_dir / 'upper_santa_rita_creek.geojson'

# open the geojson
gdf = gpd.read_file(geojson)

gdf
```

```{python}
import matplotlib.pyplot as plt
import contextily as cx

fig, ax = plt.subplots(figsize=(10, 10))
gdf.to_crs(epsg=3857).plot(
  edgecolor='r',
  ax=ax,
  facecolor='none')
cx.add_basemap(
  ax=ax,
  source=cx.providers.USGS.USImageryTopo
)

```



```{python}
import geodatasets
chicago = gpd.read_file(geodatasets.get_path('geoda.chicago_commpop'))
chicago.head()
```

Plot Cloropleth

```{python}
chicago.plot(column="POP2010")
```

The Chicago example is taken from  [GeoPandas Mapping and plotting tools](https://geopandas.org/en/stable/docs/user_guide/mapping.html) tutorial, which you should take a look at.  

# Working with Rasters in Python

## rioXarray

